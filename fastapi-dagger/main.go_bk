package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"dagger.io/dagger"
)

// FastapiDagger holds the Dagger client methods
type FastapiDagger struct {
	client *dagger.Client
}

// NewFastapiDagger creates a new FastapiDagger instance
func NewFastapiDagger(client *dagger.Client) *FastapiDagger {
	return &FastapiDagger{
		client: client,
	}
}

type HelloDagger struct{}

// Returns a container that echoes whatever string argument is provided
func (m *HelloDagger) ContainerEcho(stringArg string) *dagger.Container {
	return dag.Container().From("alpine:latest").WithExec([]string{"echo", stringArg})
}

// Returns lines that match a pattern in the files of the provided Directory
func (m *HelloDagger) GrepDir(ctx context.Context, directoryArg *dagger.Directory, pattern string) (string, error) {
	return dag.Container().
		From("alpine:latest").
		WithMountedDirectory("/mnt", directoryArg).
		WithWorkdir("/mnt").
		WithExec([]string{"grep", "-R", pattern, "."}).
		Stdout(ctx)
}


// // ContainerEcho returns a container that echoes whatever string argument is provided
// func (f *FastapiDagger) ContainerEcho(ctx context.Context, stringArg string) (*dagger.Container, error) {
// 	return f.client.Container().
// 		From("alpine:latest").
// 		WithExec([]string{"echo", stringArg}), nil
// }

// // GrepDir returns lines that match a pattern in the files of the provided Directory
// func (f *FastapiDagger) GrepDir(ctx context.Context, directoryArg *dagger.Directory, pattern string) (string, error) {
// 	output, err := f.client.Container().
// 		From("alpine:latest").
// 		WithMountedDirectory("/mnt", directoryArg).
// 		WithWorkdir("/mnt").
// 		WithExec([]string{"grep", "-R", pattern, "."}).
// 		Stdout(ctx)

// 	if err != nil {
// 		return "", fmt.Errorf("failed to grep directory: %w", err)
// 	}

// 	return output, nil
// }

// BuildAndPush builds a Docker image and pushes it to a registry
// func (f *FastapiDagger) BuildAndPush(
// 	ctx context.Context,
// 	registry string,
// 	imageName string,
// 	source *dagger.Directory,
// ) error {
// 	// Build the Docker image
// 	builtImage, err := f.client.Container().
// 		Build(source, dagger.ContainerBuildOpts{
// 			Dockerfile: "./Dockerfile",
// 		}).
// 		WithLabel("version", "1.0.0")

// 	if err != nil {
// 		return "", fmt.Errorf("failed to build image: %w", err)
// 	}

// 	// Push the Docker image
// 	ref := fmt.Sprintf("%s/%s:latest", registry, imageName)
// 	_, err = builtImage.Publish(ctx, ref)
// 	if err != nil {
// 		return "", fmt.Errorf("failed to push image: %w", err)
// 	}

// 	return nil
// }

type CommentBody struct {
	Body string `json:"body"`
}

// ScanAndPR runs a code scan and posts results to a PR
func (m *FastapiDagger) ScanAndPR(
	ctx context.Context, 
	prNumber string, 
	githubRepo string, 
	githubToken string, 
	source *dagger.Directory,
) (string, error) {
	client, err := dagger.Connect(ctx)
	if err != nil {
		return "", err
	}
	defer client.Close()

	// Run code scan
	scanOutput, err := client.Container().
		From("python:3.10").
		WithMountedDirectory("/src", source).
		WithWorkdir("/src").
		WithExec([]string{"pip", "install", "-r", "requirements.txt"}).
		WithExec([]string{"sh", "-c", "flake8 app || true"}).
		Stdout(ctx)
	if err != nil {
		return "", err
	}

	// Prepare GitHub comment
	commentBody := struct {
		Body string `json:"body"`
	}{
		Body: fmt.Sprintf("## Scan Results\n\n```\n%s\n```", scanOutput),
	}
	jsonBody, err := json.Marshal(commentBody)
	if err != nil {
		return "", err
	}

	// Create GitHub API request
	commentURL := fmt.Sprintf(
		"https://api.github.com/repos/%s/issues/%s/comments", 
		githubRepo, 
		prNumber,
	)
	
	req, err := http.NewRequestWithContext(
		ctx, 
		"POST", 
		commentURL, 
		bytes.NewBuffer(jsonBody),
	)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", githubToken))
	req.Header.Set("Content-Type", "application/json")

	// Send the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode == 201 {
		return "Comment posted successfully!", nil
	}

	return fmt.Sprintf("Failed to post comment. Status: %d", resp.StatusCode), nil
}